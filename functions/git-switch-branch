#!/usr/bin/env bash

VERSION="1.0.0"

show_help() {
    cat << EOF
git-switch-branch - Interactive git branch switching tool

Usage: git-switch-branch [OPTIONS]

OPTIONS:
    -r, --remote    Include remote branches in selection
    -c, --create    Create and switch to a new branch
    -s, --stash     Auto-stash changes before switching
    -t, --recent    Sort by most recently checked out
    -h, --help      Show this help message
    -v, --version   Show version

DESCRIPTION:
    Interactively select and switch between git branches.
    Shows branch name, last commit date, commit message, and sync status.

EXAMPLES:
    git-switch-branch           # Interactive branch selection
    git-switch-branch --remote  # Include remote branches
    git-switch-branch --stash   # Stash changes before switch
    gsb                         # Using alias

EOF
}

check_dependencies() {
    if ! command -v gum &> /dev/null; then
        echo "‚ùå Error: gum is required but not installed."
        echo ""
        echo "Install gum via Homebrew:"
        echo "  brew install gum"
        echo ""
        echo "Or visit: https://github.com/charmbracelet/gum"
        return 1
    fi

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "‚ùå Error: Not in a git repository"
        return 1
    fi
}

get_current_branch() {
    git rev-parse --abbrev-ref HEAD 2>/dev/null
}

check_uncommitted_changes() {
    ! git diff-index --quiet HEAD 2>/dev/null
}

get_branches_with_info() {
    local current_branch="$1"
    local include_remote="$2"
    local sort_recent="$3"

    local refs="refs/heads/"
    if [[ "$include_remote" == "true" ]]; then
        refs="refs/heads/ refs/remotes/"
    fi

    local sort_key="committerdate"
    if [[ "$sort_recent" == "true" ]]; then
        sort_key="reflog"
    fi

    git for-each-ref \
        --sort="-$sort_key" \
        --format='%(refname:short)|%(committerdate:relative)|%(subject)' \
        $refs | while IFS='|' read -r branch date message; do

        if [[ "$branch" == "$current_branch" ]]; then
            continue
        fi

        if [[ "$branch" == *"HEAD"* ]]; then
            continue
        fi

        printf "%-35s  \033[90m(%s)\033[0m  %s\n" \
            "$branch" \
            "$date" \
            "${message:0:60}"
    done
}

get_branch_names() {
    local current_branch="$1"
    local include_remote="$2"

    local refs="refs/heads/"
    if [[ "$include_remote" == "true" ]]; then
        refs="refs/heads/ refs/remotes/"
    fi

    git for-each-ref --format='%(refname:short)' $refs | while read -r branch; do
        if [[ "$branch" == "$current_branch" ]]; then
            continue
        fi

        if [[ "$branch" == *"HEAD"* ]]; then
            continue
        fi

        echo "$branch"
    done
}

create_new_branch() {
    local branch_name
    branch_name=$(gum input --placeholder "Enter new branch name")

    if [[ -z "$branch_name" ]]; then
        echo ""
        echo "‚úã Branch name cannot be empty"
        return 1
    fi

    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
        echo ""
        echo "‚ùå Branch '$branch_name' already exists"
        return 1
    fi

    if git checkout -b "$branch_name" 2>/dev/null; then
        echo ""
        echo "‚úÖ Created and switched to branch: $branch_name"
        return 0
    else
        echo ""
        echo "‚ùå Failed to create branch: $branch_name"
        return 1
    fi
}

main() {
    local include_remote=false
    local create_branch=false
    local auto_stash=false
    local sort_recent=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            -r|--remote)
                include_remote=true
                shift
                ;;
            -c|--create)
                create_branch=true
                shift
                ;;
            -s|--stash)
                auto_stash=true
                shift
                ;;
            -t|--recent)
                sort_recent=true
                shift
                ;;
            -h|--help)
                show_help
                return 0
                ;;
            -v|--version)
                echo "git-switch-branch version $VERSION"
                return 0
                ;;
            *)
                echo "Unknown option: $1"
                echo "Use -h or --help for usage information"
                return 1
                ;;
        esac
    done

    check_dependencies || return 1

    if [[ "$create_branch" == true ]]; then
        create_new_branch
        return $?
    fi

    local current_branch
    current_branch=$(get_current_branch)

    echo "üîÄ Interactive Branch Switcher"
    echo ""
    echo -e "Current branch: \033[1;32m$current_branch\033[0m"

    if check_uncommitted_changes; then
        echo -e "\033[1;33m‚ö†Ô∏è  Uncommitted changes detected\033[0m"

        if [[ "$auto_stash" == true ]]; then
            echo "üì¶ Stashing changes..."
            git stash push -m "git-switch-branch auto-stash $(date +%Y-%m-%d\ %H:%M:%S)"
        elif ! gum confirm "Continue without stashing?"; then
            echo ""
            echo "üí° Tip: Use --stash to automatically stash changes"
            return 0
        fi
    fi

    echo ""

    local branch_list
    branch_list=$(get_branch_names "$current_branch" "$include_remote")

    if [[ -z "$branch_list" ]]; then
        echo "‚ú® No other branches found!"
        return 0
    fi

    local sort_msg=""
    if [[ "$sort_recent" == true ]]; then
        sort_msg=" (sorted by recent)"
    fi

    echo "Select a branch to switch to$sort_msg:"
    echo ""

    local branches_display
    branches_display=$(get_branches_with_info "$current_branch" "$include_remote" "$sort_recent")

    local selected_branch
    selected_branch=$(echo "$branches_display" | gum choose --height=15)

    if [[ -z "$selected_branch" ]]; then
        echo ""
        echo "‚úã No branch selected. Exiting."
        return 0
    fi

    local branch_name
    branch_name=$(echo "$selected_branch" | awk '{print $1}')

    if [[ "$branch_name" == origin/* ]] || [[ "$branch_name" == */* ]]; then
        local local_branch="${branch_name#origin/}"
        local_branch="${local_branch##*/}"

        if git show-ref --verify --quiet "refs/heads/$local_branch"; then
            branch_name="$local_branch"
        fi
    fi

    echo ""
    echo "üîÑ Switching to: $branch_name"

    if git checkout "$branch_name" 2>&1; then
        echo ""
        echo "‚úÖ Successfully switched to: $branch_name"
    else
        echo ""
        echo "‚ùå Failed to switch to: $branch_name"
        return 1
    fi
}

main "$@"
